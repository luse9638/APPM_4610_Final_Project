function divided_diff(y_vec, n, k):
    // Returns [y_n, y_(n-1), ..., y_(n-k)]

function determine_BDF_order(): // What parameters?
    // Returns order of BDF method to use

function interpolate(t_vec, y_vec):
    // Returns polynomial interpolating the nodes specified by t_vec and y_vec
    // using divided differences (5.2.5) in book
    
function calc_stepsize(): // What parameters?
    // Returns step size

function poly_derivative(poly):
    // Returns derivative of the polynomial poly

function calc_step_quants(): // What parameters?
    // Calculate all the quantities from (5.2.4) in book

function estimate_LTE(): // What parameters?
    // Estimate the LTE of the DASSL method

function newtons_method(f, df, x_0, tol, N_max):
    // Find x such that f(x) = 0
    // f: function
    // df: derivative of f
    // x_0: initial guess
    // tol: desired tolerance between successive approximations
    // N_max: maximum iterations to run
    
    // Returns x_app where f(x_app) ~= 0
    
    // Terminate when more than 4 iterations occur

function dassl(f, t_0, t_f, y_0, dy_0, h_0, newt_tol):
    // f(t, y, dy) = 0
    // y(t_0) = y_0
    // dy(t_0) = dy_0
    // h_0 is initial stepsize
    // newt_tol is tolerance to use for Newton's method

    // Initialize vectors
    t_vec = [t_0]
    w_vec = [y_0]
    dw_vec = [dy_0]
    h_vec = []
    k_vec = [1] // What should the very first BDF order be?

    // Time stepping loop
    // Each iteration computes t_{j+1}, w_{j+1}, dw_{j+1}, h_{j+1} ?
    // using t_j, w_j, dw_j, and h_j
    while True: // Fix this condition later

        // Get values from previous time step
        t_j = t_vec[-1]
        w_j = w_vec[-1]
        dw_j = dw_vec[-1]
        k_j = k_vec[-1]
        if first_step: // creating w_1 from w_0, dw_0, h_0, t_0
            h_{j-1} = None // We haven't had a successful time step yet
        else:
            h_{j-1} = h_vec[-1] // t_j = t_{j-1} + h_{j-1}

        // Vectors of stepsizes and approximations trialed for current time step
        h_j_trial_vec = []
        w_j_trial_vec = []
        dw_j_trial_vec - []

        // Approximation at current time step loop
        // Continue looping until we are happy with our final approximation at
        // this specific time step
        while True: // Fix this condition later

            // Determine order of BDF method to use
            k_{j+1} = determine_BDF_order() // What parameters?

            // Determine step size to use
            h_j = calc_stepsize() // what parameters?
                                    // t_{j+1} = t_j + h_j

            // Get previous {k+1} approximations to use in predictor polynomial,
            // wp_{j+1}(t)
            tp_vec = [t_vec[j-jj] for jj in [0, k]]
            wp_vec = [w_vec[j-jj] for jj in [0, k]]

            // Form predictor polynomials
            // Satisifes wp_{j+1}(t_{j-jj}) = w_{j-jj} for jj in [0, k]
            //           dwp_{j+1}(t_{j-jj}) = dw_{j-jj} for jj in [0, k]
            wp_{j+1}(t) = interpolate(tp_vec, wp_vec)
            dwp_{j+1}(t) = poly_derivative(wp_{j+1}(t)) // Maybe just form this 
                                                        // using nodes from dw_vec?

            // Vector of stepsizes trialed for Newton's method
            h_j_newt_vec = []

            // Newton iteration loop
            // Continue retrying Newton's method with smaller stepsizes until
            // we are within tolerance error
            newt_iter_count = 0
            while True: // Fix this condition later
                        // Terminates after 10 consecutive failures or when
                        // t_j + h_j ~= t_j at machine precision

                // Create initial approximations for w_{j+1} and dw_{j+1}
                h_newt_j = calc_newt_stepsize(h_j, r_newt, newt_iter_count) // What parameters?
                                                                            // Book recommends r_newt = 1/4
                t_{j+1} = t_j + h_newt_j
                w0_{j+1} = wp_{j+1}(t_{j+1})
                dw0_{j+1} = dwp_{j+1}(t_{j+1})

                // Create function to run Newton's method on
                // Solving f_newt(t, w, alpha*y + beta) = 0 for w
                // Compute alpha and beta
                alpha, beta = calc_step_quants()[] // What parameters/indices?
                f_newt(w) = f(t_{j+1}, w, alpha*w + beta)
                df_newt(w) = f'(t_{j+1}, w, alpha*w + beta) // How to find this
                                                            // derivative?
                      
                // Run Newton's method and get its status
                w_newt_{j+1}, converged = newtons_method(f_newt, df_newt, w0_{j+1}, tol, 4) // How to choose tolerance?
                h_j_newt_vec.append(h_newt_j)
                newt_iter_count += 1

                // Decide if we need to retry Newton's method with a smaller
                // time step or not
                if converged: // No need to retry!
                    // Update the trialed stepsizes and approximations
                    h_j_trial_vec.append(h_j_newt)
                    w_j_trial_vec.append(w_newt_{j+1})
                    dw_j_trial_vec.append(alpha*w_newt_{j+1} + beta) // How to calculate dw_newt_{j+1}?
                    break // exit the newton iteration loop
                else: // Retry with a smaller step size
                    continue // continue the newton iteration loop

            

